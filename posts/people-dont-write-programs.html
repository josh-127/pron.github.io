<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="generator" content="Jekyll">
    <link rel="canonical" href="/posts/people-dont-write-programs"/>
    <!--<link rel="canonical" href="/posts/people-dont-write-programs">-->

    <title>People Don't Write Programs</title>
    <meta name="description" content="Ron Pressler's blog
">

<!-- Favicon -->
    <link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32.png">
    <link rel="icon" type="image/x-icon" href="/fav/favicon.ico" />
    <link rel="shortcut icon" type="image/png"    href="/fav/favicon-16.png">
    <link rel="shortcut icon" type="image/x-icon" href="/fav/favicon.ico"/>
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/fav/favicon-152.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/fav/favicon-72.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/fav/favicon-114.png">
    <!--
    <link rel="apple-touch-icon-precomposed" sizes="57x57"   href="/fav/favicon-57.png">
    <link rel="apple-touch-icon-precomposed" sizes="60x60"   href="/fav/favicon-60.png">
    <link rel="apple-touch-icon-precomposed" sizes="76x76"   href="/fav/favicon-76.png">
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/fav/favicon-120.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/fav/favicon-144.png">
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/fav/favicon-180.png">
    -->
    <!--
    <link rel="icon" type="image/png" href="/fav/favicon-96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/fav/favicon-192.png" sizes="192x192">
    -->

    <meta name="msapplication-TileColor" content="#FFFFFF">
    <meta name="msapplication-TileImage" content="/fav/favicon-144.png">
    <meta name="theme-color" content="#ffffff">

    <!-- CSS & fonts -->
    <link rel="stylesheet" type="text/css" href="/css/main.css">

  <!-- <link rel="stylesheet" type="text/css" href="/css/print.css" media="print"> -->
    <!--
    <script data-cfasync="false" type="text/javascript" src="//use.typekit.net/pfn0abv.js"></script>
    <script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link href='http://fonts.googleapis.com/css?family=Arimo:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    -->

    <!-- RSS -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />


    <!-- Social cards -->
    <!-- Twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@pressron">
<meta name="twitter:title" content="People Don't Write Programs">

  <meta name="twitter:description" content="When thinking about software verification, we tell ourselves a story about how people write programs. This story isn't true.
">



<!-- OpenGraph -->
<meta property="og:site_name" content="Ron Pressler">
<meta property="og:type" content="article">
<meta property="og:title" content="People Don't Write Programs">

  <meta property="og:description" content="When thinking about software verification, we tell ourselves a story about how people write programs. This story isn't true.
">

<meta property="og:url" content="/posts/people-dont-write-programs">
<meta property="og:image" content="http://www.gravatar.com/avatar/c69557151e2f8331f6b1865469b694dd?s=200">

<meta property="article:published_time" content="2018-04-28">


    


    
        <meta property="article:tag" content="misc">
    


    <meta name="twitter:site" content="@pressron">
</head>


<body>
	<div id="wrap">

	  <!-- Navigation -->
	  <nav id="nav">
    
        <div id="nav-toc">
        </div>
    
	<div id="nav-list">
		<a href="/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="/about" title="About">About</a>
	    
	  
	    
	  
	    
	      <a href="/computation-logic-algebra" title="Finite of Sense and Infinite of Thought:<br/>A History of Computation, Logic and Algebra">Finite of Sense and Infinite of Thought:<br/>A History of Computation, Logic and Algebra</a>
	    
	  
	    
	  
	    
	  
	    
	      <a href="/tlaplus" title="TLA<sup>+</sup> in Practice and Theory">TLA<sup>+</sup> in Practice and Theory</a>
	    
	  
	    
	  

    <!-- Nav links -->
	  


	</div>

    <footer>

	<!-- <span>version </span> -->

</footer>

</nav>


    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">
      <a href="/">
        <h1>
          <span>press</span>ron
        </h1>
      </a>
    </span>
    <!--
    <span id="nav-links" class="absolute right bottom">
	    
	      
	    
	      
	        <a href="/about" title="About">About</a>
	      
	    
	      
	    
	      
	        <a href="/computation-logic-algebra" title="Finite of Sense and Infinite of Thought:<br/>A History of Computation, Logic and Algebra">Finite of Sense and Infinite of Thought:<br/>A History of Computation, Logic and Algebra</a>
	      
	    
	      
	    
	      
	    
	      
	        <a href="/tlaplus" title="TLA<sup>+</sup> in Practice and Theory">TLA<sup>+</sup> in Practice and Theory</a>
	      
	    
	      
	    

	    


    </span>
    -->
  </div>
</header>

      

    <!-- Main content -->
	  <div id="container">

	  <main>
			<article id="post-page" class="group tufte">
	<h2>People Don't Write Programs</h2>		
	<time datetime="2018-04-28T00:00:00+01:00" class="by-line">28 Apr 2018</time>
	<div class="content">

		<p>Recently I participated in some online discussions about the relative merits of various software verification tools and techniques. This post is not about that. I think that, while different tools and approaches currently differ in the scale of programs they can verify, it is safe to say that, when considering current tools, it’s easy to come up with examples that are relatively easy to prove correct and virtually impossible to model-check, examples that are trivial to model-check and virtually impossible to prove, and examples that are beyond the reach of either. There are examples where reasoning is most easily done following the syntactic composition of a program, and examples where a different, non-syntactic composition makes things easier.</p>

<p>What I do want to discuss is an implicit assumption at the core of <em>all</em> formal methods. The reason for this assumption is that we know of the strong theoretical results showing that software verification <em>in general</em> (i.e., in the worst case) is infeasible. While programs written in some high-level language could have potentially made things easier, even in the worst case (as the number of programs expressible as humanly-manageable code is vastly smaller than the total number of hypothetical programs), we know that, sadly, linguistic abstractions do not improve things <em>in general</em> (see my post, <a href="https://pron.github.io/posts/correctness-and-complexity"><em>Why Writing Correct Software Is Hard</em></a> for a discussion of important results). And yet, we persist in trying to come up with various tools that could mechanically or semi-mechanically verify our software, including proof assistants, model checkers, abstract-interpretation sound static analysis, unsound static analysis and concolic testing. Some of these tools aim high at achieving bug-free programs (model checkers, formal proofs), some aim a bit lower (concolic testing), and some mostly try to reduce or eliminate certain common and harmful classes of bugs (static analysis, ownership types). The approaches vary both in their depth (whether they aim to find any arbitrary kind of bug or just certain classes) and their breadth (whether they aim to eliminate bugs completely or to reduce their incidence), and can differ widely in cost. The only reason we try so hard despite the grim theoretical limits is that we believe that many or most programs are far from the theoretical worst case. But why do we believe that?</p>

<p>One reason is that we simply have no choice. Maybe most programs are far from the worst-case and maybe they’re not, but until we know for sure, we must try to assume that we can help, hopefully even significantly. This is a reasonable stance, and one that I completely identify with. But such a perspective is essentially humble: we’re not certain of success, but we try to do our best. Because some positions expressed in the various discussions are not so humble, I think there is another, more self-assured belief that underlies the core assumption of software verification, and it is based on a story: People write programs, and those programs often enough work more-or-less as expected. If a person writes a certain program, this means that they have some mental model of why it should work. This mental model must be simple enough for the programmer to hold it in a limited human mind. Either this mental model is true, in which case it should be, in principle, not too hard to translate to a formal proof or verify with a model-checker, or it isn’t, in which case the model-checker would find a counter example and the programmer would despair from the proof. Put simply, the belief is that if a person is smart enough to write a more-or-less working program, then it can be verified by some mechanical means.</p>

<p>While I certainly cannot disprove this belief, I am less certain of its validity, and therefore less certain that it’s a sure guarantee of our eventual ability to mechanically and fully verify real programs. The reason is that the very premise of this story — that people write programs — is wrong.</p>

<p>It is common to see this implicit belief in exasperated statements made by programmers. They say how ridiculous it is that we’ve been “reduced” to treating software systems empirically, as if they were a mysterious natural phenomenon rather than man-made objects. But the truth is that many if not most man-made systems behave in the same way. People make the economy, yet economists are far less successful than natural scientists in modeling the system they study. Politics is made by people, but we are equally hopeless at precisely modeling it.</p>

<p>People don’t write programs like in the story. I may be exaggerating — but not too much — in saying that people write programs only in the same sense that people make the economy, and while writing them they have a mental model with similar accuracy and similar predictive capability as they do of the economy when they participate in it. This mental model is not sufficient for mechanization, even with human guidance. My vague understanding of economics means I’m fairly certain that if I buy a car I won’t topple the economy of Sweden; proving it is another matter. Yet, my inability to precisely model, and therefore mechanically and accurately reason about the economy does not preclude the economy from behaving more-or-less reasonably much of the time.</p>

<p>An average business software has about five million lines of code. It is not at uncommon to find software five and ten times that size. The program is written and maintained by a team scores or even hundreds of programmers at any one time, many more during its entire lifetime; none of them has written “the program.” In a good team, many programmers would have a vague understanding of some significant portion of the system (say, 30-80%) and a thorough understanding of a very small portion of it (5-10%). A programmer doesn’t write a program. She writes a feature — or ten. This feature interacts with the other ten thousand features in the program in ways that are hard for the programmer to predict with precision.</p>

<p>At this point, the clever but inexperienced verification fan would say, “Aha! That’s precisely why decomposition is so important! Every software component specifies its interface to the environment of other components, and our programmer can use that to reason mechanically about the feature’s interaction.” Unfortunately, this reasoning is faulty for a number of reasons.</p>

<p>The first is rather technical, but it shows why this whole endeavor ain’t easy. Assuming we were to attach those component specifications to some syntactic component of the program, the syntactic abstractions offered to us by established programming paradigms, either imperative or functional — both products of the 1930s and ’40s, where notions of computation and computers were very different from those we have today — are ultimately based on decomposition into subroutines, and this decomposition does not align well with how features are composed. For example — forgive me, my examples are always terrible — suppose that a slideshow program has a save button that opens a dialog asking for a file name, and we want to add a feature that if the file name given is not the one from which the slideshow was loaded, and it already exists, the program display a dialog warning about a possible overwrite. Adding this feature to a program compose of subroutines will not entail the addition of new components, but a modification of existing ones. Not only would we need to reason about interaction of specifications of components, we would actually need to change existing specifications, including the specifications of all components that depend on the component we’re changing. Simple solutions, like naming the specification of the save operation (say, giving it a nominal type) and reusing it in all components that depend on it, doesn’t work. Doing so would change the specification of another feature we have, say autosave, and we may not want that specification to change because we do not want the autosave feature to behave in the same way (horrible example, but I hope you get the picture). The complete program may then work according to the formal specification, but it is only because of an automatic and unwanted change to that specification. There are modern programming paradigms that try to make the syntactic or structural composition of programs better match our mental composition of features, like <a href="http://www.wisdom.weizmann.ac.il/~bprogram/">behavioral programming</a>, but they’re not mainstream.<sup id="fnref:formal-law"><a href="#fn:formal-law" class="footnote">1</a></sup></p>

<p>A bigger difficulty is that it is not true that it is always easy to reason about the interaction of two or more well-specified components. In fact, <a href="https://pron.github.io/posts/correctness-and-complexity#correctness-does-not-decompose">another important result</a> shows that verifying the interaction of components is, in the worst case, no easier than verifying all the components as one, meaning it requires the same effort and understanding as writing a non-decomposed program would. No single person wrote that whole program, and none of the authors of the components has ever had the mental model required to prove their composition.</p>

<p>So we need another story to explain why we believe composition is feasible. That story may go like this: People write each component for a reason and so should have a clear enough understanding of at least what it does, and this entails a simple interface specification. I think that both the premise and the conclusion of this story are suspect, and even if we believe them, I am not sure that the conclusion is a sufficient condition to guarantee a feasible cost of verifying the composition of specifications.</p>

<p>I am not at all pessimistic about the prospects of various tools and techniques in increasing the reliability of software or increasing our ability to create larger systems with similar reliability. But I do think we need to be <em>cautious</em> when betting on this or that approach. We already have various tools that have proven effective in some real-world cases. But they’re not silver bullets; far from it.<sup id="fnref:silver-bullet"><a href="#fn:silver-bullet" class="footnote">2</a></sup></p>

<p>The story of the person with the clear mental image certainly does apply when what they’re writing is an algorithm or even a high-level system design. Indeed, algorithms and architectures can often be given a manageable, fully-mechanizable mathematical representation. But people write algorithms and high-level designs; people don’t exactly write actual real-world software systems, at least not like in the story.</p>

<div class="footnotes">
  <ol>
    <li id="fn:formal-law">
      <p>A similar formalism has been proposed as a basis for <a href="https://www.youtube.com/watch?v=EshxZVMURt4">formal reasoning about tax code</a>.&nbsp;<a href="#fnref:formal-law" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:silver-bullet">
      <p>I should add that these days many advocates for certain tools and techniques are fully aware that most programmers are wary of promises of silver bullets, and so when describing what they actually do seem to believe is a silver bullet they add, “it’s not a silver bullet.” I propose that when making this empty qualification, advocates would be required to explain <em>why</em> what they’re advocating is not a silver bullet. If they can’t, they are probably crypto-silver-bulletists who do not understand well enough the problems they pretend to solve.&nbsp;<a href="#fnref:silver-bullet" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


	</div>
</article>

	  </main>

    <!-- Pagination links -->
    

  </div>

	    <!-- Footer -->
	    <footer></footer>


	    <!-- Script -->
      <script type="text/javascript" src="/js/main.js"></script>
<!-- <script src="/js/vendor/modernizr-2.6.2.min.js"></script> -->
    <!--[if lt IE 9]>
        <script src="js/vendor/html5shiv.js"></script>
        <![endif]-->

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!--
<script>window.jQuery || document.write('<script src="/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
-->

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99776245-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- <script>
var _gaq=[['_setAccount','UA-99776245-1'],['_trackPageview']];
(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src='//www.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script> -->


	<script type="text/javascript" src="/js/toc.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#nav-toc').toc();
});
</script>

<script type="text/javascript" src="/js/bigfoot.min.js"></script>

<script type="text/javascript">
    $.bigfoot();
</script>





	</div>
</body>
</html>
